<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>METRO</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      dialog {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        gap: 10px;
        border: 1px solid #000;

        & input {
          width: 50px;
        }
      }

      fieldset {
        padding: 10px 5px;
      }

      input {
        padding: 0 5px;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      canvas {
        border: 1px solid #000;
      }

      .container {
        margin-top: 50px;
        width: 1350px;
        height: 500px;
        display: flex;
        justify-content: space-between;

        & > .config-container {
          height: 100%;
          width: 300px;
          display: flex;
          flex-direction: column;
          justify-content: space-between;

          & .config-content {
            display: flex;
            flex-direction: column;
            gap: 10px;

            & .nodes {
              display: flex;
              flex-direction: column;
              gap: 5px;
              max-height: 300px;
              overflow: auto;
              position: relative;

              & .nodes-list {
                display: flex;
                flex-direction: column;
                gap: 5px;
                padding: 0 5px;
                width: 100%;

                & .nodes-list-header {
                  & div {
                    width: 100%;
                    display: flex;
                    gap: 30px;
                  }
                }

                & .node {
                  width: 100%;
                  display: flex;
                  align-items: center;
                  justify-content: space-between;

                  & div {
                    width: 100%;
                    display: flex;
                    gap: 20px;
                  }
                }
              }

              & .add_node {
                width: 100%;
              }

              & .node_input-container {
                width: 100%;
                background: #fff;
                padding: 5px;
                position: sticky;
                bottom: -10px;

                & > .node_input {
                  display: flex;
                  gap: 5px;

                  #node_x {
                    width: 50px;
                  }

                  #node_y {
                    width: 50px;
                  }

                  #node_label {
                    width: 100%;
                  }
                }
              }
            }

            & .path {
              display: flex;
              width: 100;
              max-height: 200px;
              flex-direction: column;
              gap: 5px;

              & .path_input {
                display: flex;
                gap: 10px;

                & input {
                  width: 100%;
                }

                & button {
                  width: 100%;
                }
              }
            }
          }
        }
      }
    </style>
  </head>
  <body>
    <dialog id="modal">
      <div>
        <table id="edges">
          <thead></thead>
          <tbody></tbody>
        </table>
        <button onclick="window.modal.close()">Close</button>
      </div>
    </dialog>
    <div class="container">
      <div class="config-container">
        <div class="config-content">
          <h3>config</h3>
          <fieldset class="nodes">
            <legend>nodes</legend>
            <div class="nodes-list"></div>
            <div class="node_input-container">
              <div class="node_input">
                <input
                  type="number"
                  id="node_x"
                  min="0"
                  max="1000"
                  placeholder="x"
                  required
                />
                <input
                  type="number"
                  id="node_y"
                  min="0"
                  max="500"
                  placeholder="y"
                  required
                />
                <input
                  type="text"
                  id="node_label"
                  placeholder="label"
                  required
                />
              </div>
              <button class="add_node">+ add node</button>
            </div>
          </fieldset>
          <button onclick="window.modal.showModal()">Edit edge</button>
          <fieldset class="path">
            <legend>path</legend>
            <div class="path_input">
              <input
                type="number"
                id="path_from"
                min="0"
                placeholder="from(node id)"
              />
              <input
                type="number"
                id="path_to"
                min="0"
                placeholder="to(node id)"
              />
            </div>
            <button onclick="drawPath()">Draw path</button>
          </fieldset>
        </div>
        <button id="button" style="display: none">Draw</button>
        <button id="save" onclick="saveConfig()">Save</button>
      </div>
      <div class="canvas-container">
        <canvas id="canvas" width="1000" height="500"></canvas>
      </div>
    </div>

    <script>
      function drawNodeUI() {
        const nodes_el = document.querySelector(".nodes-list");
        nodes_el.innerHTML = `<div class="nodes-list-header"><div><span>id</span><span>x</span><span>y</span><span>label</span></div></div>`;
        nodes.forEach((node) => {
          addNodeToUI(node);
        });
      }
      function addNodeToUI(node) {
        const { id, x, y, label } = node;

        const nodes_el = document.querySelector(".nodes-list");
        const child = document.createElement("div");
        child.classList.add("node");
        child.innerHTML = `<div><span>${id}</span>
                          <span>${x}</span>
                          <span>${y}</span>
                          <span>${label}</span></div>
                          <button onclick="deleteNode(${id})">delete</button>`;
        nodes_el.append(child);
      }

      function deleteNode(node_id) {
        edges = edges.filter((edge, ind) => ind !== node_id);
        let edges_copy = [...edges];
        edges = [];
        const copy = [...nodes];
        nodes = new Proxy([], nodesProxyHandler);
        copy.forEach((node, ind) => {
          if (ind !== node_id) {
            if (ind > node_id) {
              nodes.push({ ...node, id: node.id - 1 });
            } else nodes.push(node);
          }
        });

        edges = edges_copy.map((edge) =>
          edge.filter((el, ind) => ind !== node_id)
        );

        drawNodeUI();
        drawEdgesTable();
        drawMap();
      }

      const pathProxyHandler = {
        get(target, property, receiver) {
          const value = Reflect.get(target, property, receiver);
          if (property === "add") {
            return function (element) {
              const res = value.call(target, element);
              drawMap();
              return res;
            };
          } else if (property === "delete") {
            return function (element) {
              const res = value.call(target, element);
              drawMap();
              return res;
            };
          } else if (property === "has") {
            return function (element) {
              return value.call(target, element);
            };
          } else if (property === "clear") {
            return function () {
              value.call(target);
            };
          } else if (property === "indexOf") {
            return function (element) {
              return value.call(target, element);
            };
          } else
            return function (element) {
              return value.call(target, element);
            };

          return value;
        },
      };

      let path = new Set();
      path = new Proxy(path, pathProxyHandler);

      let edges = [];

      const nodesProxyHandler = {
        get(target, property) {
          if (property === "push") {
            if (edges) edges.forEach((el) => el.push(0));
            edges.push(new Array(nodes.length + 1).fill(0));
            drawEdgesTable();
            return function (...args) {
              args.forEach((item) => target.push(item));
            };
          }

          return target[property];
        },
      };

      let nodes = [];
      nodes = new Proxy(nodes, nodesProxyHandler);

      const add_node = document.querySelector(".add_node");
      const node_x = document.querySelector("#node_x");
      const node_y = document.querySelector("#node_y");
      const node_label = document.querySelector("#node_label");

      add_node.addEventListener("click", () => {
        if (node_x.value == "" || node_y.value == "") return;

        const id = nodes.length;
        nodes.push({
          id: id,
          x: parseInt(node_x.value),
          y: parseInt(node_y.value),
          label: node_label.value ? node_label.value : id,
        });

        drawNode(nodes[id]);
        addNodeToUI(nodes[id]);
      });

      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const pathColor = "rgba(255, 0, 0, 1)";

      const radius = 12;
      const nameBelow = true;

      function drawNode(node) {
        const { id, x, y, label } = node;
        if (path.has(id)) {
          ctx.fillStyle = pathColor;
        }
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.arc(x, y, radius * 0.75, 0, 2 * Math.PI);
        ctx.fill();
        ctx.closePath();

        ctx.fillText(
          label,
          x - label.toString().length * 3,
          y + radius * 2 * (nameBelow ? 1 : -1)
        );

        ctx.fillStyle = "#000";
      }

      function drawEdgesFor(node_id) {
        const edge = edges[node_id];
        const from = nodes[node_id];

        edge.map((is, ind) => {
          if (!!is) {
            if (path.has(node_id) && path.has(ind)) {
              const arr_path = Array.from(path);
              const index_path = arr_path.indexOf(ind);
              const node_path = arr_path.indexOf(node_id);
              if (index_path === node_path + 1 || index_path === node_path - 1)
                ctx.strokeStyle = pathColor;
            }
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(nodes[ind].x, nodes[ind].y);
            ctx.stroke();
            ctx.strokeStyle = "#000";
          }
        });
      }

      function clear() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function drawMap() {
        clear();
        const notInPath = nodes.filter((el) => !path.has(el.id));
        const inPath = nodes.filter((el) => path.has(el.id));

        notInPath.forEach((node) => {
          ctx.fillStyle = "#000";
          ctx.strokeStyle = "#000";
          drawEdgesFor(node.id);
          drawNode(node);
        });

        inPath.forEach((node) => {
          ctx.fillStyle = "#000";
          ctx.strokeStyle = "#000";
          drawEdgesFor(node.id);
          drawNode(node);
        });
      }

      const button = document.getElementById("button");
      const input = document.getElementById("input");

      button.addEventListener("click", () => {
        drawMap();
      });

      function drawEdgesTable() {
        const table = document.querySelector("#edges tbody");
        const table_header = document.querySelector("#edges thead");

        table.innerHTML = "";
        table_header.innerHTML = "";

        const header_row = document.createElement("tr");
        for (let i = 0; i <= edges.length; i++) {
          if (i === 0) header_row.innerHTML += `<th></th>`;
          else header_row.innerHTML += `<th>${i - 1}</th>`;
        }
        table_header.appendChild(header_row);

        for (let i = 0; i < edges.length; i++) {
          const row = document.createElement("tr");
          for (let j = 0; j <= edges[i].length; j++) {
            let cell;
            if (j !== 0) {
              cell = document.createElement("td");
              const input = document.createElement("input");
              input.type = "number";
              input.value = edges[i][j - 1];
              input.disabled = i === j - 1;
              input.onchange = (e) => {
                edges[i][j - 1] = parseInt(e.target.value);
                edges[j - 1][i] = parseInt(e.target.value);
                drawEdgesTable();
                drawMap();
              };
              cell.appendChild(input);
            } else {
              cell = document.createElement("th");
              cell.innerHTML = i;
            }
            row.appendChild(cell);
          }
          table.appendChild(row);
        }
      }

      function saveConfig() {
        localStorage.setItem("nodes", JSON.stringify(nodes));
        localStorage.setItem("edges", JSON.stringify(edges));
      }

      function loadConfig() {
        if (localStorage.getItem("nodes") && localStorage.getItem("edges")) {
          nodes = JSON.parse(localStorage.getItem("nodes"));
          edges = JSON.parse(localStorage.getItem("edges"));
          nodes = new Proxy(nodes, nodesProxyHandler);
          drawMap();
          drawEdgesTable();
          drawNodeUI();
        }
      }

      loadConfig();

      function findShortestPath(startNodeID, endNodeID) {
        const matrix = [...edges];
        const queue = [startNodeID];
        const visited = new Set();
        const shortestDistances = new Array(matrix.length).fill(Infinity);
        shortestDistances[startNodeID] = 0;
        const prevNode = new Array(matrix.length).fill(null);

        while (queue.length > 0) {
          const currentNode = queue.shift();

          if (currentNode === endNodeID) {
            break;
          }

          for (
            let neighbor = 0;
            neighbor < matrix[currentNode].length;
            neighbor++
          ) {
            if (matrix[currentNode][neighbor] === 1 && !visited.has(neighbor)) {
              queue.push(neighbor);
              visited.add(neighbor);
              if (
                shortestDistances[currentNode] + 1 <
                shortestDistances[neighbor]
              ) {
                shortestDistances[neighbor] =
                  shortestDistances[currentNode] + 1;
                prevNode[neighbor] = currentNode;
              }
            }
          }
        }

        if (prevNode[endNodeID] === null) {
          return {
            path: [],
            distance: Infinity,
          };
        }

        const path = [];
        let currentNode = endNodeID;
        while (currentNode !== null) {
          path.unshift(currentNode);
          currentNode = prevNode[currentNode];
        }

        return {
          path: path,
          distance: shortestDistances[endNodeID],
        };
      }

      function drawPath() {
        path.clear();
        if (window.path_from.value == "" || window.path_to.value == "")
          return drawMap();

        const short_path = findShortestPath(
          parseInt(window.path_from.value),
          parseInt(window.path_to.value)
        );
        if (!short_path);
        else {
          const interval = setInterval(() => {
            const node = short_path.path.shift();
            path.add(node);
            if (short_path.path.length === 0) clearInterval(interval);
          }, 600);
        }
      }
    </script>
  </body>
</html>
